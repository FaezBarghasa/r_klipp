<!-- File path: docs/hil_testing.md -->

Hardware-In-the-Loop (HIL) Testing Plan

This document outlines the procedures for conducting Hardware-In-the-Loop (HIL) tests on the r_klipp firmware. HIL testing is critical for validating the firmware's interaction with real-world hardware and measuring its real-time performance characteristics.

Section 1: Setup

Required Hardware

Target MCU Board:

An MKS SKIPR board (STM32F407VET6) or another supported board, flashed with a dedicated HIL test firmware binary.

Logic Analyzer:

A multi-channel logic analyzer capable of at least 24MHz sampling rate (e.g., Saleae Logic 8, DSLogic).

Sufficient channels to capture STEP, DIR, and communication pins simultaneously.

Oscilloscope:

A 2-channel digital storage oscilloscope (DSO) with at least 50MHz bandwidth. Useful for analyzing signal integrity and jitter in finer detail.

Current Probe:

A DC current probe or a high-precision shunt resistor with a differential probe for measuring motor and heater current draw.

External Thermocouple/Thermometer:

A calibrated K-type thermocouple with a MAX31855/MAX6675 breakout board, or a high-accuracy infrared thermometer.

Host Computer:

A PC running Linux, with the logic analyzer/oscilloscope software and a serial terminal program.

Wiring

Connect the logic analyzer's input channels to the STEP and DIR pins of at least two stepper motor drivers (e.g., X and Y).

Connect another logic analyzer channel to a GPIO pin that the test firmware will use as a "command received" trigger.

Connect the oscilloscope probe to one of the STEP pins for jitter analysis.

Attach the external thermocouple to the heater block, adjacent to the printer's own thermistor.

Section 2: Test Procedures

Test 1: Step Timing Accuracy and Jitter

Objective: Verify that the time between step pulses generated by the MCU exactly matches the interval_ticks commanded by the planner and measure the jitter.

Procedure:

Create a special test firmware that executes a pre-programmed move with a constant cruise velocity (i.e., all StepCommands have the same interval_ticks). For example, a move of 10,000 steps with an interval of 5000 ticks (20,000 steps/sec at 100MHz).

Start a capture with the logic analyzer on the STEP pin.

Power on the MCU to run the test firmware.

Stop the capture after the move is complete.

Analysis:

Using the logic analyzer software, place markers on a long sequence of rising edges of the step pulses.

Measure the time between consecutive pulses. This should be consistent and equal to interval_ticks / CLOCK_FREQ. For our example, 5000 / 100,000,000 = 50µs.

Use the software's statistics or measurement tools to calculate the standard deviation of the period. This value is the jitter. For a real-time system, this should be extremely low, ideally less than 1µs.

Test 2: Thermal Stability and PID Performance

Objective: Evaluate the performance of the PID controller by monitoring its ability to reach and maintain a target temperature, and to verify that the reported temperature matches a calibrated external sensor.

Procedure:

Flash the standard r_klipp firmware to the MCU.

Connect the external thermocouple to the heater block.

Connect the host and issue a command to heat the hotend to 210°C (SET_HEATER_TEMPERATURE HEATER=extruder TARGET=210).

Log the temperature data from both the printer's thermistor (via Klipper's status_report) and the external thermocouple simultaneously over a period of 5-10 minutes.

Issue a command to turn on the part cooling fan to 100% to simulate a thermal disturbance.

Analysis:

Plot both temperature series over time.

Accuracy: Check the difference between the steady-state temperature reported by the firmware and the external thermocouple. This should be within an acceptable tolerance (e.g., ±2°C).

Overshoot: Measure the amount the temperature exceeds the 210°C target on the initial heat-up.

Stability: Once at temperature, measure the peak-to-peak fluctuation. This should ideally be less than ±1°C.

Disturbance Rejection: Analyze how the temperature drops when the fan turns on and how quickly the PID controller recovers to the setpoint.

Test 3: End-to-End Latency

Objective: Measure the time from the moment a G-code command is sent from the host to the first corresponding step pulse being generated by the MCU.

Procedure:

Create a test firmware that sets a specific GPIO pin (TRIGGER_PIN) high as the very first action inside the UART receive interrupt/task when a specific, known command is received.

Connect the logic analyzer to the host's UART TX pin, the MCU's TRIGGER_PIN, and the X-axis STEP pin.

Set the logic analyzer to trigger on the falling edge of the last byte of the G1 command sent over UART.

Send a simple G1 X10 F6000 command from the host.

Analysis:

Measure the time delta T1 between the trigger (end of UART command) and the rising edge of the TRIGGER_PIN. This is the MCU's internal command processing latency.

Measure the time delta T2 between the rising edge of the TRIGGER_PIN and the first pulse on the STEP pin. This is the motion planning and step generation latency.

The total end-to-end latency is T1 + T2. This value is a key metric for the real-time responsiveness of the system.